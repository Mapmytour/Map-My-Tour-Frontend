import { apiClient } from '@/lib/api';
import { API_ENDPOINTS } from '@/lib/api-endpoints';
import {
  Booking,
  BookingParticipant,
  BookingPayment,
  BookingNotification,
  BookingNote,
  CustomerDetails,
  BookingPricing,
  CancellationPolicy,
  BookingFilters,
  BookingStatus,
  BookingType,
  PaymentStatus,
  PaymentMethod,
  PaymentType,
  ParticipantStatus,
  BookingSource,
  CreateBookingRequest,
  UpdateBookingRequest,
  AddParticipantRequest,
  CancelParticipantRequest,
  ProcessPaymentRequest,
  CancelBookingRequest,
  BookingStats,
} from '@/types/booking';
import { APIResponse } from '@/types/APIResponse';
import { Currency } from '@/types/common';

// ========================
// Additional Request Types
// ========================

export interface SearchBookingsRequest {
  query: string;
  filters?: BookingFilters;
  sortBy?: 'bookingNumber' | 'bookingDate' | 'travelDate' | 'totalAmount' | 'status' | 'customerName';
  sortOrder?: 'asc' | 'desc';
  page?: number;
  limit?: number;
}

export interface ConfirmBookingRequest {
  bookingId: string;
  sendConfirmation?: boolean;
  autoGenerateDocuments?: boolean;
  notes?: string;
}

export interface ModificationRequest {
  bookingId: string;
  type: 'date-change' | 'participant-change' | 'service-upgrade' | 'other';
  details: {
    newTravelDate?: string;
    newEndDate?: string;
    participantChanges?: {
      add?: Omit<BookingParticipant, 'id' | 'status' | 'addedAt' | 'finalPrice'>[];
      remove?: string[];
      update?: { participantId: string; changes: Partial<BookingParticipant> }[];
    };
    serviceChanges?: any;
    reason?: string;
  };
  requestedBy: string;
  customerApproval?: boolean;
}

export interface NotificationRequest {
  type: 'confirmation' | 'reminder' | 'payment' | 'cancellation' | 'update' | 'custom';
  method: 'email' | 'sms' | 'push' | 'whatsapp' | 'all';
  recipients?: string[];
  customMessage?: string;
  scheduleFor?: string;
  includeAttachments?: boolean;
}

export interface AvailabilityCheckRequest {
  entityType: BookingType;
  entityId: string;
  date: string;
  endDate?: string;
  participants: number;
  participantTypes?: { adults: number; children: number; infants: number };
}

export interface BulkOperationRequest {
  bookingIds: string[];
  operation: 'confirm' | 'cancel' | 'update-status' | 'send-notification' | 'process-payment' | 'export';
  data?: any;
  reason?: string;
  notifyCustomers?: boolean;
}

export interface RevenueReportRequest {
  dateRange: {
    from: string;
    to: string;
  };
  groupBy?: 'day' | 'week' | 'month' | 'quarter';
  entityType?: BookingType;
  currency?: Currency;
  includeRefunds?: boolean;
}

export interface WaitlistRequest {
  entityType: BookingType;
  entityId: string;
  date: string;
  participants: number;
  customerDetails: CustomerDetails;
  contactPreferences: string[];
  maxWaitTime?: number; // days
  autoBook?: boolean;
}

class BookingService {
  // ========================
  // Basic CRUD Operations
  // ========================

  /**
   * Get all bookings with optional filters
   */
  async getAllBookings(filters?: BookingFilters): Promise<APIResponse<{
    bookings: Booking[];
    total: number;
    page: number;
    limit: number;
    pages: number;
  }>> {
    try {
      const params = filters ? this.buildFilterParams(filters) : undefined;
      const response = await apiClient.get<{
        bookings: Booking[];
        total: number;
        page: number;
        limit: number;
        pages: number;
      }>(API_ENDPOINTS.BOOKING.GET_ALL, params);
      return response;
    } catch (error) {
      throw new Error(`Failed to fetch bookings: ${error}`);
    }
  }

  /**
   * Get booking by ID
   */
  async getBookingById(id: string): Promise<APIResponse<Booking>> {
    try {
      const endpoint = API_ENDPOINTS.BOOKING.GET_BY_ID.replace(':id', id);
      const response = await apiClient.get<Booking>(endpoint);
      return response;
    } catch (error) {
      throw new Error(`Failed to fetch booking: ${error}`);
    }
  }

  /**
   * Get booking by booking number
   */
  async getBookingByNumber(bookingNumber: string): Promise<APIResponse<Booking>> {
    try {
      const endpoint = API_ENDPOINTS.BOOKING.GET_BY_NUMBER.replace(':bookingNumber', bookingNumber);
      const response = await apiClient.get<Booking>(endpoint);
      return response;
    } catch (error) {
      throw new Error(`Failed to fetch booking by number: ${error}`);
    }
  }

  /**
   * Create new booking
   */
  async createBooking(data: CreateBookingRequest): Promise<APIResponse<Booking>> {
    try {
      const response = await apiClient.post<Booking>(
        API_ENDPOINTS.BOOKING.CREATE,
        data
      );
      return response;
    } catch (error) {
      throw new Error(`Failed to create booking: ${error}`);
    }
  }

  /**
   * Update booking
   */
  async updateBooking(data: UpdateBookingRequest): Promise<APIResponse<Booking>> {
    try {
      const endpoint = API_ENDPOINTS.BOOKING.UPDATE.replace(':id', data.id);
      const { id, ...updateData } = data;
      const response = await apiClient.put<Booking>(endpoint, updateData);
      return response;
    } catch (error) {
      throw new Error(`Failed to update booking: ${error}`);
    }
  }

  /**
   * Delete booking
   */
  async deleteBooking(id: string): Promise<APIResponse<{ message: string }>> {
    try {
      const endpoint = API_ENDPOINTS.BOOKING.DELETE.replace(':id', id);
      const response = await apiClient.delete<{ message: string }>(endpoint);
      return response;
    } catch (error) {
      throw new Error(`Failed to delete booking: ${error}`);
    }
  }

  /**
   * Duplicate booking
   */
  async duplicateBooking(id: string, modifications?: Partial<CreateBookingRequest>): Promise<APIResponse<Booking>> {
    try {
      const endpoint = API_ENDPOINTS.BOOKING.DUPLICATE.replace(':id', id);
      const response = await apiClient.post<Booking>(endpoint, modifications);
      return response;
    } catch (error) {
      throw new Error(`Failed to duplicate booking: ${error}`);
    }
  }

  // ========================
  // Search and Filter
  // ========================

  /**
   * Search bookings
   */
  async searchBookings(request: SearchBookingsRequest): Promise<APIResponse<{
    bookings: Booking[];
    total: number;
    page: number;
    limit: number;
    pages: number;
  }>> {
    try {
      const response = await apiClient.post<{
        bookings: Booking[];
        total: number;
        page: number;
        limit: number;
        pages: number;
      }>(API_ENDPOINTS.BOOKING.SEARCH, request);
      return response;
    } catch (error) {
      throw new Error(`Failed to search bookings: ${error}`);
    }
  }

  /**
   * Filter bookings
   */
  async filterBookings(filters: BookingFilters): Promise<APIResponse<Booking[]>> {
    try {
      const response = await apiClient.post<Booking[]>(
        API_ENDPOINTS.BOOKING.FILTER,
        filters
      );
      return response;
    } catch (error) {
      throw new Error(`Failed to filter bookings: ${error}`);
    }
  }

  /**
   * Get bookings by status
   */
  async getBookingsByStatus(status: BookingStatus): Promise<APIResponse<Booking[]>> {
    try {
      const endpoint = API_ENDPOINTS.BOOKING.BY_STATUS.replace(':status', status);
      const response = await apiClient.get<Booking[]>(endpoint);
      return response;
    } catch (error) {
      throw new Error(`Failed to fetch bookings by status: ${error}`);
    }
  }

  /**
   * Get bookings by customer
   */
  async getBookingsByCustomer(customerId: string): Promise<APIResponse<Booking[]>> {
    try {
      const endpoint = API_ENDPOINTS.BOOKING.BY_CUSTOMER.replace(':customerId', customerId);
      const response = await apiClient.get<Booking[]>(endpoint);
      return response;
    } catch (error) {
      throw new Error(`Failed to fetch bookings by customer: ${error}`);
    }
  }

  /**
   * Get bookings by entity
   */
  async getBookingsByEntity(entityType: BookingType, entityId: string): Promise<APIResponse<Booking[]>> {
    try {
      const endpoint = API_ENDPOINTS.BOOKING.BY_ENTITY
        .replace(':entityType', entityType)
        .replace(':entityId', entityId);
      const response = await apiClient.get<Booking[]>(endpoint);
      return response;
    } catch (error) {
      throw new Error(`Failed to fetch bookings by entity: ${error}`);
    }
  }

  // ========================
  // Participant Management
  // ========================

  /**
   * Get booking participants
   */
  async getParticipants(bookingId: string): Promise<APIResponse<BookingParticipant[]>> {
    try {
      const endpoint = API_ENDPOINTS.BOOKING.GET_PARTICIPANTS.replace(':id', bookingId);
      const response = await apiClient.get<BookingParticipant[]>(endpoint);
      return response;
    } catch (error) {
      throw new Error(`Failed to fetch participants: ${error}`);
    }
  }

  /**
   * Add participant to booking
   */
  async addParticipant(bookingId: string, data: AddParticipantRequest): Promise<APIResponse<{
    participant: BookingParticipant;
    updatedPricing: BookingPricing;
  }>> {
    try {
      const endpoint = API_ENDPOINTS.BOOKING.ADD_PARTICIPANT.replace(':id', bookingId);
      const response = await apiClient.post<{
        participant: BookingParticipant;
        updatedPricing: BookingPricing;
      }>(endpoint, data);
      return response;
    } catch (error) {
      throw new Error(`Failed to add participant: ${error}`);
    }
  }

  /**
   * Update participant
   */
  async updateParticipant(bookingId: string, participantId: string, data: Partial<BookingParticipant>): Promise<APIResponse<BookingParticipant>> {
    try {
      const endpoint = API_ENDPOINTS.BOOKING.UPDATE_PARTICIPANT
        .replace(':id', bookingId)
        .replace(':participantId', participantId);
      const response = await apiClient.put<BookingParticipant>(endpoint, data);
      return response;
    } catch (error) {
      throw new Error(`Failed to update participant: ${error}`);
    }
  }

  /**
   * Cancel participant
   */
  async cancelParticipant(bookingId: string, data: CancelParticipantRequest): Promise<APIResponse<{
    participant: BookingParticipant;
    refundAmount: number;
    updatedPricing: BookingPricing;
  }>> {
    try {
      const endpoint = API_ENDPOINTS.BOOKING.CANCEL_PARTICIPANT
        .replace(':id', bookingId)
        .replace(':participantId', data.participantId);
      const response = await apiClient.post<{
        participant: BookingParticipant;
        refundAmount: number;
        updatedPricing: BookingPricing;
      }>(endpoint, data);
      return response;
    } catch (error) {
      throw new Error(`Failed to cancel participant: ${error}`);
    }
  }

  /**
   * Check in participant
   */
  async checkInParticipant(bookingId: string, participantId: string): Promise<APIResponse<BookingParticipant>> {
    try {
      const endpoint = API_ENDPOINTS.BOOKING.CHECK_IN_PARTICIPANT
        .replace(':id', bookingId)
        .replace(':participantId', participantId);
      const response = await apiClient.post<BookingParticipant>(endpoint);
      return response;
    } catch (error) {
      throw new Error(`Failed to check in participant: ${error}`);
    }
  }

  // ========================
  // Payment Management
  // ========================

  /**
   * Get booking payments
   */
  async getPayments(bookingId: string): Promise<APIResponse<BookingPayment[]>> {
    try {
      const endpoint = API_ENDPOINTS.BOOKING.GET_PAYMENTS.replace(':id', bookingId);
      const response = await apiClient.get<BookingPayment[]>(endpoint);
      return response;
    } catch (error) {
      throw new Error(`Failed to fetch payments: ${error}`);
    }
  }

  /**
   * Process payment
   */
  async processPayment(data: ProcessPaymentRequest): Promise<APIResponse<{
    payment: BookingPayment;
    booking: Booking;
    receipt?: string;
  }>> {
    try {
      const endpoint = API_ENDPOINTS.BOOKING.PROCESS_PAYMENT.replace(':id', data.bookingId);
      const response = await apiClient.post<{
        payment: BookingPayment;
        booking: Booking;
        receipt?: string;
      }>(endpoint, data);
      return response;
    } catch (error) {
      throw new Error(`Failed to process payment: ${error}`);
    }
  }

  /**
   * Refund payment
   */
  async refundPayment(bookingId: string, paymentId: string, amount?: number, reason?: string): Promise<APIResponse<{
    refund: BookingPayment;
    booking: Booking;
  }>> {
    try {
      const endpoint = API_ENDPOINTS.BOOKING.REFUND_PAYMENT
        .replace(':id', bookingId)
        .replace(':paymentId', paymentId);
      const response = await apiClient.post<{
        refund: BookingPayment;
        booking: Booking;
      }>(endpoint, { amount, reason });
      return response;
    } catch (error) {
      throw new Error(`Failed to refund payment: ${error}`);
    }
  }

  /**
   * Calculate pricing
   */
  async calculatePricing(bookingId: string, changes?: any): Promise<APIResponse<BookingPricing>> {
    try {
      const endpoint = API_ENDPOINTS.BOOKING.CALCULATE_PRICING.replace(':id', bookingId);
      const response = await apiClient.post<BookingPricing>(endpoint, changes);
      return response;
    } catch (error) {
      throw new Error(`Failed to calculate pricing: ${error}`);
    }
  }

  /**
   * Apply promo code
   */
  async applyPromoCode(bookingId: string, code: string): Promise<APIResponse<{
    discount: any;
    updatedPricing: BookingPricing;
  }>> {
    try {
      const endpoint = API_ENDPOINTS.BOOKING.APPLY_PROMO_CODE
        .replace(':id', bookingId)
        .replace(':code', code);
      const response = await apiClient.post<{
        discount: any;
        updatedPricing: BookingPricing;
      }>(endpoint);
      return response;
    } catch (error) {
      throw new Error(`Failed to apply promo code: ${error}`);
    }
  }

  // ========================
  // Status Management
  // ========================

  /**
   * Update booking status
   */
  async updateStatus(bookingId: string, status: BookingStatus, reason?: string): Promise<APIResponse<Booking>> {
    try {
      const endpoint = API_ENDPOINTS.BOOKING.UPDATE_STATUS.replace(':id', bookingId);
      const response = await apiClient.put<Booking>(endpoint, { status, reason });
      return response;
    } catch (error) {
      throw new Error(`Failed to update booking status: ${error}`);
    }
  }

  /**
   * Confirm booking
   */
  async confirmBooking(data: ConfirmBookingRequest): Promise<APIResponse<Booking>> {
    try {
      const endpoint = API_ENDPOINTS.BOOKING.CONFIRM_BOOKING.replace(':id', data.bookingId);
      const response = await apiClient.post<Booking>(endpoint, data);
      return response;
    } catch (error) {
      throw new Error(`Failed to confirm booking: ${error}`);
    }
  }

  /**
   * Cancel booking
   */
  async cancelBooking(data: CancelBookingRequest): Promise<APIResponse<{
    booking: Booking;
    refundAmount: number;
    cancellationFee: number;
  }>> {
    try {
      const endpoint = API_ENDPOINTS.BOOKING.CANCEL_BOOKING.replace(':id', data.bookingId);
      const response = await apiClient.post<{
        booking: Booking;
        refundAmount: number;
        cancellationFee: number;
      }>(endpoint, data);
      return response;
    } catch (error) {
      throw new Error(`Failed to cancel booking: ${error}`);
    }
  }

  /**
   * Complete booking
   */
  async completeBooking(bookingId: string, feedback?: any): Promise<APIResponse<Booking>> {
    try {
      const endpoint = API_ENDPOINTS.BOOKING.COMPLETE_BOOKING.replace(':id', bookingId);
      const response = await apiClient.post<Booking>(endpoint, { feedback });
      return response;
    } catch (error) {
      throw new Error(`Failed to complete booking: ${error}`);
    }
  }

  // ========================
  // Communication & Notifications
  // ========================

  /**
   * Send notification
   */
  async sendNotification(bookingId: string, notification: NotificationRequest): Promise<APIResponse<BookingNotification>> {
    try {
      let endpoint: string;
      switch (notification.type) {
        case 'confirmation':
          endpoint = API_ENDPOINTS.BOOKING.SEND_CONFIRMATION;
          break;
        case 'reminder':
          endpoint = API_ENDPOINTS.BOOKING.SEND_REMINDER;
          break;
        case 'payment':
          endpoint = API_ENDPOINTS.BOOKING.SEND_PAYMENT_REMINDER;
          break;
        case 'cancellation':
          endpoint = API_ENDPOINTS.BOOKING.SEND_CANCELLATION_NOTICE;
          break;
        default:
          endpoint = API_ENDPOINTS.BOOKING.SEND_CUSTOM_NOTIFICATION;
      }

      endpoint = endpoint.replace(':id', bookingId);
      const response = await apiClient.post<BookingNotification>(endpoint, notification);
      return response;
    } catch (error) {
      throw new Error(`Failed to send notification: ${error}`);
    }
  }

  /**
   * Get communication history
   */
  async getCommunicationHistory(bookingId: string): Promise<APIResponse<BookingNotification[]>> {
    try {
      const endpoint = API_ENDPOINTS.BOOKING.GET_COMMUNICATION_HISTORY.replace(':id', bookingId);
      const response = await apiClient.get<BookingNotification[]>(endpoint);
      return response;
    } catch (error) {
      throw new Error(`Failed to fetch communication history: ${error}`);
    }
  }

  // ========================
  // Notes Management
  // ========================

  /**
   * Get booking notes
   */
  async getNotes(bookingId: string): Promise<APIResponse<BookingNote[]>> {
    try {
      const endpoint = API_ENDPOINTS.BOOKING.GET_NOTES.replace(':id', bookingId);
      const response = await apiClient.get<BookingNote[]>(endpoint);
      return response;
    } catch (error) {
      throw new Error(`Failed to fetch notes: ${error}`);
    }
  }

  /**
   * Add note
   */
  async addNote(bookingId: string, note: Omit<BookingNote, 'id' | 'createdAt'>): Promise<APIResponse<BookingNote>> {
    try {
      const endpoint = API_ENDPOINTS.BOOKING.ADD_NOTE.replace(':id', bookingId);
      const response = await apiClient.post<BookingNote>(endpoint, note);
      return response;
    } catch (error) {
      throw new Error(`Failed to add note: ${error}`);
    }
  }

  // ========================
  // Documents & Waivers
  // ========================

  /**
   * Generate voucher
   */
  async generateVoucher(bookingId: string, format: 'pdf' | 'html' = 'pdf'): Promise<APIResponse<{ url: string; expiresAt: string }>> {
    try {
      const endpoint = API_ENDPOINTS.BOOKING.GENERATE_VOUCHER.replace(':id', bookingId);
      const response = await apiClient.post<{ url: string; expiresAt: string }>(endpoint, { format });
      return response;
    } catch (error) {
      throw new Error(`Failed to generate voucher: ${error}`);
    }
  }

  /**
   * Generate invoice
   */
  async generateInvoice(bookingId: string, format: 'pdf' | 'html' = 'pdf'): Promise<APIResponse<{ url: string; expiresAt: string }>> {
    try {
      const endpoint = API_ENDPOINTS.BOOKING.GENERATE_INVOICE.replace(':id', bookingId);
      const response = await apiClient.post<{ url: string; expiresAt: string }>(endpoint, { format });
      return response;
    } catch (error) {
      throw new Error(`Failed to generate invoice: ${error}`);
    }
  }

  /**
   * Sign waiver
   */
  async signWaiver(bookingId: string, signature: string, participantId?: string): Promise<APIResponse<{ signed: boolean; document: string }>> {
    try {
      const endpoint = API_ENDPOINTS.BOOKING.SIGN_WAIVER.replace(':id', bookingId);
      const response = await apiClient.post<{ signed: boolean; document: string }>(endpoint, { signature, participantId });
      return response;
    } catch (error) {
      throw new Error(`Failed to sign waiver: ${error}`);
    }
  }

  // ========================
  // Availability & Validation
  // ========================

  /**
   * Check availability
   */
  async checkAvailability(request: AvailabilityCheckRequest): Promise<APIResponse<{
    available: boolean;
    capacity: number;
    remaining: number;
    alternatives?: any[];
  }>> {
    try {
      const response = await apiClient.post<{
        available: boolean;
        capacity: number;
        remaining: number;
        alternatives?: any[];
      }>(API_ENDPOINTS.BOOKING.CHECK_AVAILABILITY, request);
      return response;
    } catch (error) {
      throw new Error(`Failed to check availability: ${error}`);
    }
  }

  /**
   * Validate booking
   */
  async validateBooking(bookingId: string): Promise<APIResponse<{
    valid: boolean;
    errors: string[];
    warnings: string[];
  }>> {
    try {
      const endpoint = API_ENDPOINTS.BOOKING.VALIDATE_BOOKING.replace(':id', bookingId);
      const response = await apiClient.get<{
        valid: boolean;
        errors: string[];
        warnings: string[];
      }>(endpoint);
      return response;
    } catch (error) {
      throw new Error(`Failed to validate booking: ${error}`);
    }
  }

  // ========================
  // Cancellation & Refunds
  // ========================

  /**
   * Get cancellation policy
   */
  async getCancellationPolicy(bookingId: string): Promise<APIResponse<CancellationPolicy>> {
    try {
      const endpoint = API_ENDPOINTS.BOOKING.GET_CANCELLATION_POLICY.replace(':id', bookingId);
      const response = await apiClient.get<CancellationPolicy>(endpoint);
      return response;
    } catch (error) {
      throw new Error(`Failed to fetch cancellation policy: ${error}`);
    }
  }

  /**
   * Calculate cancellation cost
   */
  async calculateCancellation(bookingId: string, date?: string): Promise<APIResponse<{
    refundAmount: number;
    cancellationFee: number;
    policy: CancellationPolicy;
  }>> {
    try {
      const endpoint = API_ENDPOINTS.BOOKING.CALCULATE_CANCELLATION.replace(':id', bookingId);
      const response = await apiClient.post<{
        refundAmount: number;
        cancellationFee: number;
        policy: CancellationPolicy;
      }>(endpoint, { cancellationDate: date });
      return response;
    } catch (error) {
      throw new Error(`Failed to calculate cancellation: ${error}`);
    }
  }

  // ========================
  // Reports & Analytics
  // ========================

  /**
   * Get booking statistics
   */
  async getBookingStats(dateRange?: { from: string; to: string }): Promise<APIResponse<BookingStats>> {
    try {
      const response = await apiClient.get<BookingStats>(
        API_ENDPOINTS.BOOKING.GET_STATS,
        dateRange ? { from: dateRange.from, to: dateRange.to } : undefined
      );
      return response;
    } catch (error) {
      throw new Error(`Failed to fetch booking statistics: ${error}`);
    }
  }

  /**
   * Get revenue report
   */
  async getRevenueReport(request: RevenueReportRequest): Promise<APIResponse<{
    totalRevenue: number;
    data: any[];
    summary: any;
  }>> {
    try {
      const response = await apiClient.post<{
        totalRevenue: number;
        data: any[];
        summary: any;
      }>(API_ENDPOINTS.BOOKING.GET_REVENUE_REPORT, request);
      return response;
    } catch (error) {
      throw new Error(`Failed to fetch revenue report: ${error}`);
    }
  }

  /**
   * Export bookings
   */
  async exportBookings(filters?: BookingFilters, format: 'excel' | 'csv' | 'pdf' = 'excel'): Promise<APIResponse<{ url: string; expiresAt: string }>> {
    try {
      const response = await apiClient.post<{ url: string; expiresAt: string }>(
        API_ENDPOINTS.BOOKING.EXPORT_BOOKINGS,
        { filters, format }
      );
      return response;
    } catch (error) {
      throw new Error(`Failed to export bookings: ${error}`);
    }
  }

  // ========================
  // Bulk Operations
  // ========================

  /**
   * Bulk operations on bookings
   */
  async bulkOperation(request: BulkOperationRequest): Promise<APIResponse<{
    processed: number;
    failed: number;
    results: any[];
  }>> {
    try {
      let endpoint: string;
      switch (request.operation) {
        case 'confirm':
          endpoint = API_ENDPOINTS.BOOKING.BULK_CONFIRM;
          break;
        case 'cancel':
          endpoint = API_ENDPOINTS.BOOKING.BULK_CANCEL;
          break;
        case 'update-status':
          endpoint = API_ENDPOINTS.BOOKING.BULK_UPDATE_STATUS;
          break;
        case 'send-notification':
          endpoint = API_ENDPOINTS.BOOKING.BULK_SEND_NOTIFICATIONS;
          break;
        case 'process-payment':
          endpoint = API_ENDPOINTS.BOOKING.BULK_PROCESS_PAYMENTS;
          break;
        case 'export':
          endpoint = API_ENDPOINTS.BOOKING.BULK_EXPORT;
          break;
        default:
          throw new Error('Invalid bulk operation');
      }

      const response = await apiClient.post<{
        processed: number;
        failed: number;
        results: any[];
      }>(endpoint, request);
      return response;
    } catch (error) {
      throw new Error(`Failed to perform bulk operation: ${error}`);
    }
  }

  // ========================
  // Calendar & Scheduling
  // ========================

  /**
   * Get calendar view
   */
  async getCalendar(year: number, month: number, entityType?: BookingType): Promise<APIResponse<{
    days: { date: string; bookings: number; revenue: number }[];
    summary: any;
  }>> {
    try {
      const params: any = { year: year.toString(), month: month.toString() };
      if (entityType) params.entityType = entityType;

      const response = await apiClient.get<{
        days: { date: string; bookings: number; revenue: number }[];
        summary: any;
      }>(API_ENDPOINTS.BOOKING.GET_CALENDAR, params);
      return response;
    } catch (error) {
      throw new Error(`Failed to fetch calendar: ${error}`);
    }
  }

  /**
   * Get upcoming departures
   */
  async getUpcomingDepartures(days: number = 7): Promise<APIResponse<Booking[]>> {
    try {
      const response = await apiClient.get<Booking[]>(
        API_ENDPOINTS.BOOKING.GET_UPCOMING_DEPARTURES,
        { days: days.toString() }
      );
      return response;
    } catch (error) {
      throw new Error(`Failed to fetch upcoming departures: ${error}`);
    }
  }

  // ========================
  // Waitlist Management
  // ========================

  /**
   * Add to waitlist
   */
  async addToWaitlist(request: WaitlistRequest): Promise<APIResponse<{ waitlistId: string; position: number }>> {
    try {
      const response = await apiClient.post<{ waitlistId: string; position: number }>(
        API_ENDPOINTS.BOOKING.ADD_TO_WAITLIST,
        request
      );
      return response;
    } catch (error) {
      throw new Error(`Failed to add to waitlist: ${error}`);
    }
  }

  /**
   * Process waitlist
   */
  async processWaitlist(entityType: BookingType, entityId: string, date: string): Promise<APIResponse<{
    processed: number;
    bookingsCreated: number;
    notified: number;
  }>> {
    try {
      const response = await apiClient.post<{
        processed: number;
        bookingsCreated: number;
        notified: number;
      }>(API_ENDPOINTS.BOOKING.PROCESS_WAITLIST, { entityType, entityId, date });
      return response;
    } catch (error) {
      throw new Error(`Failed to process waitlist: ${error}`);
    }
  }

  // ========================
  // Utility Methods
  // ========================

  /**
   * Build filter parameters for API requests
   */
  private buildFilterParams(filters: BookingFilters): Record<string, string> {
    const params: Record<string, string> = {};

    if (filters.status?.length) {
      params.status = filters.status.join(',');
    }
    if (filters.bookingType?.length) {
      params.bookingType = filters.bookingType.join(',');
    }
    if (filters.paymentStatus?.length) {
      params.paymentStatus = filters.paymentStatus.join(',');
    }
    if (filters.source?.length) {
      params.source = filters.source.join(',');
    }
    if (filters.bookingDateRange) {
      params.bookingDateFrom = filters.bookingDateRange.from;
      params.bookingDateTo = filters.bookingDateRange.to;
    }
    if (filters.travelDateRange) {
      params.travelDateFrom = filters.travelDateRange.from;
      params.travelDateTo = filters.travelDateRange.to;
    }
    if (filters.customerId) {
      params.customerId = filters.customerId;
    }
    if (filters.entityId) {
      params.entityId = filters.entityId;
    }
    if (filters.entityType) {
      params.entityType = filters.entityType;
    }
    if (filters.priceRange) {
      params.priceMin = filters.priceRange.min.toString();
      params.priceMax = filters.priceRange.max.toString();
      if (filters.priceRange.currency) {
        params.currency = filters.priceRange.currency;
      }
    }
    if (filters.participantCount) {
      params.participantMin = filters.participantCount.min.toString();
      params.participantMax = filters.participantCount.max.toString();
    }
    if (filters.searchQuery) {
      params.search = filters.searchQuery;
    }
    if (filters.hasSpecialRequests !== undefined) {
      params.hasSpecialRequests = filters.hasSpecialRequests.toString();
    }
    if (filters.requiresWaiver !== undefined) {
      params.requiresWaiver = filters.requiresWaiver.toString();
    }
    if (filters.hasRefunds !== undefined) {
      params.hasRefunds = filters.hasRefunds.toString();
    }
    if (filters.overdue !== undefined) {
      params.overdue = filters.overdue.toString();
    }

    return params;
  }

  /**
   * Format booking number
   */
  formatBookingNumber(number: string): string {
    return number.replace(/(\w{2})(\w{4})(\w+)/, '$1-$2-$3');
  }

  /**
   * Calculate booking duration
   */
  calculateDuration(startDate: string, endDate?: string): number {
    if (!endDate) return 1;
    const start = new Date(startDate);
    const end = new Date(endDate);
    return Math.ceil((end.getTime() - start.getTime()) / (1000 * 60 * 60 * 24));
  }

  /**
   * Validate participant data
   */
  validateParticipant(participant: Partial<BookingParticipant>): string[] {
    const errors: string[] = [];

    if (!participant.firstName?.trim()) {
      errors.push('First name is required');
    }
    if (!participant.lastName?.trim()) {
      errors.push('Last name is required');
    }
    if (!participant.age || participant.age < 0 || participant.age > 120) {
      errors.push('Valid age is required');
    }
    if (participant.email && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(participant.email)) {
      errors.push('Valid email is required');
    }

    return errors;
  }
}

// Export singleton instance
export const bookingService = new BookingService();